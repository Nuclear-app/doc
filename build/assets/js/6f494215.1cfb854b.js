"use strict";(self.webpackChunknuclear_docs=self.webpackChunknuclear_docs||[]).push([[98],{4256:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"development/api","title":"API Documentation","description":"Complete guide to building and consuming APIs in the Nuclear application using Next.js API routes.","source":"@site/docs/development/api.md","sourceDirName":"development","slug":"/development/api","permalink":"/docs/development/api","draft":false,"unlisted":false,"editUrl":"https://github.com/nuclear-app/doc/tree/main/docs/development/api.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"UI Framework & Styling","permalink":"/docs/development/ui-framework"},"next":{"title":"Debugging Guide","permalink":"/docs/development/debugging"}}');var s=r(4848),i=r(8453);const a={sidebar_position:8},o="API Documentation",u={},l=[{value:"\ud83d\ude80 API Overview",id:"-api-overview",level:2},{value:"Technology Stack",id:"technology-stack",level:3},{value:"Key Features",id:"key-features",level:3},{value:"\ud83c\udfd7\ufe0f API Route Structure",id:"\ufe0f-api-route-structure",level:2},{value:"File Organization",id:"file-organization",level:3},{value:"Route Naming Convention",id:"route-naming-convention",level:3},{value:"\ud83d\udcdd Creating API Routes",id:"-creating-api-routes",level:2},{value:"Basic API Route",id:"basic-api-route",level:3},{value:"Dynamic Route with ID",id:"dynamic-route-with-id",level:3},{value:"\ud83d\udd10 Authentication &amp; Authorization",id:"-authentication--authorization",level:2},{value:"Session Management",id:"session-management",level:3},{value:"Protected Route Helper",id:"protected-route-helper",level:3},{value:"Role-Based Authorization",id:"role-based-authorization",level:3},{value:"\ud83d\udcca Request Validation",id:"-request-validation",level:2},{value:"Zod Schemas",id:"zod-schemas",level:3},{value:"Validation Middleware",id:"validation-middleware",level:3},{value:"\ud83d\udd04 Error Handling",id:"-error-handling",level:2},{value:"Error Response Format",id:"error-response-format",level:3},{value:"Global Error Handler",id:"global-error-handler",level:3},{value:"\ud83d\udce1 API Client",id:"-api-client",level:2},{value:"Frontend API Client",id:"frontend-api-client",level:3},{value:"React Hooks for API",id:"react-hooks-for-api",level:3},{value:"\ud83d\ude80 Performance Optimization",id:"-performance-optimization",level:2},{value:"Caching Strategies",id:"caching-strategies",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"\ud83d\udcda Related Documentation",id:"-related-documentation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"api-documentation",children:"API Documentation"})}),"\n",(0,s.jsx)(n.p,{children:"Complete guide to building and consuming APIs in the Nuclear application using Next.js API routes."}),"\n",(0,s.jsx)(n.h2,{id:"-api-overview",children:"\ud83d\ude80 API Overview"}),"\n",(0,s.jsx)(n.h3,{id:"technology-stack",children:"Technology Stack"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Next.js 14"})," - API routes with app router"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TypeScript"})," - Type-safe API development"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prisma"})," - Database operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NextAuth.js"})," - Authentication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zod"})," - Request validation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"})," - Full TypeScript integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Validation"})," - Request/response validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"})," - Consistent error responses"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication"})," - Protected routes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate Limiting"})," - API protection"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-api-route-structure",children:"\ud83c\udfd7\ufe0f API Route Structure"}),"\n",(0,s.jsx)(n.h3,{id:"file-organization",children:"File Organization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"app/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 auth/                 # Authentication endpoints\n\u2502   \u2502   \u251c\u2500\u2500 [...nextauth]/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 route.ts\n\u2502   \u2502   \u2514\u2500\u2500 login/\n\u2502   \u2502       \u2514\u2500\u2500 route.ts\n\u2502   \u251c\u2500\u2500 users/                # User management\n\u2502   \u2502   \u251c\u2500\u2500 route.ts          # GET /api/users, POST /api/users\n\u2502   \u2502   \u2514\u2500\u2500 [id]/\n\u2502   \u2502       \u2514\u2500\u2500 route.ts      # GET /api/users/[id], PUT /api/users/[id], DELETE /api/users/[id]\n\u2502   \u251c\u2500\u2500 blocks/               # Block management\n\u2502   \u2502   \u251c\u2500\u2500 route.ts\n\u2502   \u2502   \u2514\u2500\u2500 [id]/\n\u2502   \u2502       \u2514\u2500\u2500 route.ts\n\u2502   \u251c\u2500\u2500 quizzes/              # Quiz management\n\u2502   \u2502   \u251c\u2500\u2500 route.ts\n\u2502   \u2502   \u2514\u2500\u2500 [id]/\n\u2502   \u2502       \u2514\u2500\u2500 route.ts\n\u2502   \u2514\u2500\u2500 health/               # Health check\n\u2502       \u2514\u2500\u2500 route.ts\n"})}),"\n",(0,s.jsx)(n.h3,{id:"route-naming-convention",children:"Route Naming Convention"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - RESTful naming\n/api/users          // GET, POST\n/api/users/[id]     // GET, PUT, DELETE\n/api/users/[id]/profile  // GET, PUT\n\n// \u2705 Good - Action-based naming\n/api/auth/login     // POST\n/api/auth/logout    // POST\n/api/blocks/[id]/publish  // POST\n/api/blocks/[id]/unpublish  // POST\n\n// \u274c Avoid - Inconsistent naming\n/api/getUsers\n/api/createUser\n/api/updateUserById\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-creating-api-routes",children:"\ud83d\udcdd Creating API Routes"}),"\n",(0,s.jsx)(n.h3,{id:"basic-api-route",children:"Basic API Route"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/api/users/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { prisma } from '@/lib/generated/prisma';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\n// Request validation schema\nconst createUserSchema = z.object({\n  email: z.string().email(),\n  name: z.string().min(1).max(100),\n  mode: z.enum(['STUDENT', 'TEACHER', 'ADMIN']).default('STUDENT'),\n});\n\n// GET /api/users\nexport async function GET(request: NextRequest) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    // Parse query parameters\n    const { searchParams } = new URL(request.url);\n    const page = parseInt(searchParams.get('page') || '1');\n    const limit = parseInt(searchParams.get('limit') || '10');\n    const search = searchParams.get('search') || '';\n\n    // Build query\n    const where = search ? {\n      OR: [\n        { name: { contains: search, mode: 'insensitive' } },\n        { email: { contains: search, mode: 'insensitive' } },\n      ],\n    } : {};\n\n    // Fetch users with pagination\n    const users = await prisma.user.findMany({\n      where,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        mode: true,\n        createdAt: true,\n      },\n      skip: (page - 1) * limit,\n      take: limit,\n      orderBy: { createdAt: 'desc' },\n    });\n\n    // Get total count\n    const total = await prisma.user.count({ where });\n\n    return NextResponse.json({\n      users,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n    });\n  } catch (error) {\n    console.error('GET /api/users error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// POST /api/users\nexport async function POST(request: NextRequest) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    // Parse and validate request body\n    const body = await request.json();\n    const validatedData = createUserSchema.parse(body);\n\n    // Check if user already exists\n    const existingUser = await prisma.user.findUnique({\n      where: { email: validatedData.email },\n    });\n\n    if (existingUser) {\n      return NextResponse.json(\n        { error: 'User with this email already exists' },\n        { status: 409 }\n      );\n    }\n\n    // Create user\n    const user = await prisma.user.create({\n      data: validatedData,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        mode: true,\n        createdAt: true,\n      },\n    });\n\n    return NextResponse.json(user, { status: 201 });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { error: 'Validation error', details: error.errors },\n        { status: 400 }\n      );\n    }\n\n    console.error('POST /api/users error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-route-with-id",children:"Dynamic Route with ID"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/api/users/[id]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { prisma } from '@/lib/generated/prisma';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\n// Validation schemas\nconst updateUserSchema = z.object({\n  name: z.string().min(1).max(100).optional(),\n  mode: z.enum(['STUDENT', 'TEACHER', 'ADMIN']).optional(),\n});\n\n// GET /api/users/[id]\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    const { id } = params;\n\n    // Validate ID format\n    if (!id || typeof id !== 'string') {\n      return NextResponse.json(\n        { error: 'Invalid user ID' },\n        { status: 400 }\n      );\n    }\n\n    // Fetch user\n    const user = await prisma.user.findUnique({\n      where: { id },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        mode: true,\n        createdAt: true,\n        updatedAt: true,\n        blocks: {\n          select: {\n            id: true,\n            title: true,\n            published: true,\n            createdAt: true,\n          },\n          orderBy: { createdAt: 'desc' },\n          take: 5,\n        },\n      },\n    });\n\n    if (!user) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json(user);\n  } catch (error) {\n    console.error('GET /api/users/[id] error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// PUT /api/users/[id]\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    const { id } = params;\n\n    // Validate ID format\n    if (!id || typeof id !== 'string') {\n      return NextResponse.json(\n        { error: 'Invalid user ID' },\n        { status: 400 }\n      );\n    }\n\n    // Parse and validate request body\n    const body = await request.json();\n    const validatedData = updateUserSchema.parse(body);\n\n    // Check if user exists\n    const existingUser = await prisma.user.findUnique({\n      where: { id },\n    });\n\n    if (!existingUser) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      );\n    }\n\n    // Update user\n    const user = await prisma.user.update({\n      where: { id },\n      data: validatedData,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        mode: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n\n    return NextResponse.json(user);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { error: 'Validation error', details: error.errors },\n        { status: 400 }\n      );\n    }\n\n    console.error('PUT /api/users/[id] error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE /api/users/[id]\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    const { id } = params;\n\n    // Validate ID format\n    if (!id || typeof id !== 'string') {\n      return NextResponse.json(\n        { error: 'Invalid user ID' },\n        { status: 400 }\n      );\n    }\n\n    // Check if user exists\n    const existingUser = await prisma.user.findUnique({\n      where: { id },\n    });\n\n    if (!existingUser) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      );\n    }\n\n    // Delete user\n    await prisma.user.delete({\n      where: { id },\n    });\n\n    return NextResponse.json(\n      { message: 'User deleted successfully' },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('DELETE /api/users/[id] error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-authentication--authorization",children:"\ud83d\udd10 Authentication & Authorization"}),"\n",(0,s.jsx)(n.h3,{id:"session-management",children:"Session Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/auth.ts\nimport { NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { prisma } from '@/lib/generated/prisma';\nimport bcrypt from 'bcryptjs';\n\nexport const authOptions: NextAuthOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: { email: credentials.email },\n        });\n\n        if (!user) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password,\n          user.password || ''\n        );\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          mode: user.mode,\n        };\n      },\n    }),\n  ],\n  session: {\n    strategy: 'jwt',\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.mode = user.mode;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id as string;\n        session.user.mode = token.mode as string;\n      }\n      return session;\n    },\n  },\n  pages: {\n    signIn: '/auth/login',\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"protected-route-helper",children:"Protected Route Helper"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/api-helpers.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nexport interface AuthenticatedRequest extends NextRequest {\n  user: {\n    id: string;\n    email: string;\n    name: string;\n    mode: string;\n  };\n}\n\nexport async function requireAuth(request: NextRequest): Promise<AuthenticatedRequest> {\n  const session = await getServerSession(authOptions);\n  \n  if (!session?.user) {\n    throw new Error('Unauthorized');\n  }\n\n  return {\n    ...request,\n    user: session.user,\n  };\n}\n\nexport function createErrorResponse(message: string, status: number = 400) {\n  return NextResponse.json({ error: message }, { status });\n}\n\nexport function createSuccessResponse(data: any, status: number = 200) {\n  return NextResponse.json(data, { status });\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"role-based-authorization",children:"Role-Based Authorization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/permissions.ts\nexport enum UserRole {\n  STUDENT = 'STUDENT',\n  TEACHER = 'TEACHER',\n  ADMIN = 'ADMIN',\n}\n\nexport function requireRole(allowedRoles: UserRole[]) {\n  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function(...args: any[]) {\n      const request = args[0];\n      const user = request.user;\n\n      if (!allowedRoles.includes(user.mode as UserRole)) {\n        throw new Error('Insufficient permissions');\n      }\n\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n// Usage in API route\nexport class UserController {\n  @requireRole([UserRole.ADMIN, UserRole.TEACHER])\n  async createUser(request: AuthenticatedRequest) {\n    // Only admins and teachers can create users\n  }\n\n  @requireRole([UserRole.ADMIN])\n  async deleteUser(request: AuthenticatedRequest) {\n    // Only admins can delete users\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-request-validation",children:"\ud83d\udcca Request Validation"}),"\n",(0,s.jsx)(n.h3,{id:"zod-schemas",children:"Zod Schemas"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/validations/user.ts\nimport { z } from 'zod';\n\nexport const createUserSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),\n  mode: z.enum(['STUDENT', 'TEACHER', 'ADMIN']).default('STUDENT'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n});\n\nexport const updateUserSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(100, 'Name too long').optional(),\n  mode: z.enum(['STUDENT', 'TEACHER', 'ADMIN']).optional(),\n});\n\nexport const userQuerySchema = z.object({\n  page: z.string().transform(Number).pipe(z.number().min(1)).default('1'),\n  limit: z.string().transform(Number).pipe(z.number().min(1).max(100)).default('10'),\n  search: z.string().optional(),\n  mode: z.enum(['STUDENT', 'TEACHER', 'ADMIN']).optional(),\n});\n\n// lib/validations/block.ts\nexport const createBlockSchema = z.object({\n  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),\n  content: z.string().min(1, 'Content is required'),\n  folderId: z.string().optional(),\n  published: z.boolean().default(false),\n});\n\nexport const updateBlockSchema = z.object({\n  title: z.string().min(1, 'Title is required').max(200, 'Title too long').optional(),\n  content: z.string().min(1, 'Content is required').optional(),\n  folderId: z.string().optional(),\n  published: z.boolean().optional(),\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"validation-middleware",children:"Validation Middleware"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/middleware/validation.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\n\nexport function validateRequest(schema: z.ZodSchema) {\n  return async function(request: NextRequest) {\n    try {\n      const body = await request.json();\n      const validatedData = schema.parse(body);\n      return { success: true, data: validatedData };\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return {\n          success: false,\n          error: NextResponse.json(\n            { error: 'Validation error', details: error.errors },\n            { status: 400 }\n          ),\n        };\n      }\n      return {\n        success: false,\n        error: NextResponse.json(\n          { error: 'Invalid JSON' },\n          { status: 400 }\n        ),\n      };\n    }\n  };\n}\n\n// Usage\nexport async function POST(request: NextRequest) {\n  const validation = await validateRequest(createUserSchema)(request);\n  \n  if (!validation.success) {\n    return validation.error;\n  }\n\n  const { data } = validation;\n  // Process validated data\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-error-handling",children:"\ud83d\udd04 Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"error-response-format",children:"Error Response Format"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/api-helpers.ts\nexport interface ApiError {\n  error: string;\n  message?: string;\n  details?: any;\n  code?: string;\n}\n\nexport function createErrorResponse(\n  error: string,\n  status: number = 400,\n  details?: any,\n  code?: string\n) {\n  const response: ApiError = { error };\n  \n  if (details) response.details = details;\n  if (code) response.code = code;\n  \n  return NextResponse.json(response, { status });\n}\n\n// Common error responses\nexport const ErrorResponses = {\n  unauthorized: () => createErrorResponse('Unauthorized', 401),\n  forbidden: () => createErrorResponse('Forbidden', 403),\n  notFound: (resource: string) => createErrorResponse(`${resource} not found`, 404),\n  validationError: (details: any) => createErrorResponse('Validation error', 400, details),\n  internalError: () => createErrorResponse('Internal server error', 500),\n  conflict: (message: string) => createErrorResponse(message, 409),\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"global-error-handler",children:"Global Error Handler"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/error-handler.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport function withErrorHandler(handler: Function) {\n  return async (request: NextRequest, context: any) => {\n    try {\n      return await handler(request, context);\n    } catch (error: any) {\n      console.error('API Error:', error);\n\n      // Handle specific error types\n      if (error.name === 'PrismaClientKnownRequestError') {\n        switch (error.code) {\n          case 'P2002':\n            return createErrorResponse('Resource already exists', 409);\n          case 'P2025':\n            return createErrorResponse('Resource not found', 404);\n          default:\n            return createErrorResponse('Database error', 500);\n        }\n      }\n\n      if (error.name === 'ZodError') {\n        return createErrorResponse('Validation error', 400, error.errors);\n      }\n\n      // Default error response\n      return createErrorResponse('Internal server error', 500);\n    }\n  };\n}\n\n// Usage\nexport const GET = withErrorHandler(async (request: NextRequest) => {\n  // Your API logic here\n  const users = await prisma.user.findMany();\n  return NextResponse.json(users);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-api-client",children:"\ud83d\udce1 API Client"}),"\n",(0,s.jsx)(n.h3,{id:"frontend-api-client",children:"Frontend API Client"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/api-client.ts\nclass ApiClient {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = '/api') {\n    this.baseUrl = baseUrl;\n  }\n\n  private async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    const url = `${this.baseUrl}${endpoint}`;\n    \n    const config: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    const response = await fetch(url, config);\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'API request failed');\n    }\n\n    return response.json();\n  }\n\n  // User endpoints\n  async getUsers(params?: {\n    page?: number;\n    limit?: number;\n    search?: string;\n  }): Promise<{ users: User[]; pagination: PaginationInfo }> {\n    const searchParams = new URLSearchParams();\n    if (params?.page) searchParams.set('page', params.page.toString());\n    if (params?.limit) searchParams.set('limit', params.limit.toString());\n    if (params?.search) searchParams.set('search', params.search);\n\n    const query = searchParams.toString();\n    return this.request(`/users${query ? `?${query}` : ''}`);\n  }\n\n  async getUser(id: string): Promise<User> {\n    return this.request(`/users/${id}`);\n  }\n\n  async createUser(data: CreateUserData): Promise<User> {\n    return this.request('/users', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n  }\n\n  async updateUser(id: string, data: UpdateUserData): Promise<User> {\n    return this.request(`/users/${id}`, {\n      method: 'PUT',\n      body: JSON.stringify(data),\n    });\n  }\n\n  async deleteUser(id: string): Promise<void> {\n    return this.request(`/users/${id}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Block endpoints\n  async getBlocks(params?: {\n    page?: number;\n    limit?: number;\n    authorId?: string;\n    published?: boolean;\n  }): Promise<{ blocks: Block[]; pagination: PaginationInfo }> {\n    const searchParams = new URLSearchParams();\n    if (params?.page) searchParams.set('page', params.page.toString());\n    if (params?.limit) searchParams.set('limit', params.limit.toString());\n    if (params?.authorId) searchParams.set('authorId', params.authorId);\n    if (params?.published !== undefined) searchParams.set('published', params.published.toString());\n\n    const query = searchParams.toString();\n    return this.request(`/blocks${query ? `?${query}` : ''}`);\n  }\n\n  async createBlock(data: CreateBlockData): Promise<Block> {\n    return this.request('/blocks', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n  }\n\n  async publishBlock(id: string): Promise<Block> {\n    return this.request(`/blocks/${id}/publish`, {\n      method: 'POST',\n    });\n  }\n}\n\nexport const apiClient = new ApiClient();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"react-hooks-for-api",children:"React Hooks for API"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// hooks/useApi.ts\nimport { useState, useEffect } from 'react';\nimport { apiClient } from '@/lib/api-client';\n\nexport function useUsers(params?: {\n  page?: number;\n  limit?: number;\n  search?: string;\n}) {\n  const [data, setData] = useState<{ users: User[]; pagination: PaginationInfo } | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function fetchUsers() {\n      try {\n        setLoading(true);\n        setError(null);\n        const result = await apiClient.getUsers(params);\n        setData(result);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch users');\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchUsers();\n  }, [params?.page, params?.limit, params?.search]);\n\n  return { data, loading, error };\n}\n\nexport function useUser(id: string) {\n  const [data, setData] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function fetchUser() {\n      try {\n        setLoading(true);\n        setError(null);\n        const result = await apiClient.getUser(id);\n        setData(result);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch user');\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    if (id) {\n      fetchUser();\n    }\n  }, [id]);\n\n  return { data, loading, error };\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-performance-optimization",children:"\ud83d\ude80 Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/cache.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport function withCache(handler: Function, maxAge: number = 60) {\n  return async (request: NextRequest, context: any) => {\n    const response = await handler(request, context);\n    \n    // Add cache headers\n    response.headers.set('Cache-Control', `public, max-age=${maxAge}`);\n    \n    return response;\n  };\n}\n\n// Usage\nexport const GET = withCache(async (request: NextRequest) => {\n  const users = await prisma.user.findMany();\n  return NextResponse.json(users);\n}, 300); // Cache for 5 minutes\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// lib/rate-limit.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst rateLimitMap = new Map<string, { count: number; resetTime: number }>();\n\nexport function withRateLimit(\n  handler: Function,\n  limit: number = 100,\n  windowMs: number = 15 * 60 * 1000 // 15 minutes\n) {\n  return async (request: NextRequest, context: any) => {\n    const ip = request.ip || 'unknown';\n    const now = Date.now();\n    \n    const rateLimit = rateLimitMap.get(ip);\n    \n    if (rateLimit && now < rateLimit.resetTime) {\n      if (rateLimit.count >= limit) {\n        return NextResponse.json(\n          { error: 'Rate limit exceeded' },\n          { status: 429 }\n        );\n      }\n      rateLimit.count++;\n    } else {\n      rateLimitMap.set(ip, {\n        count: 1,\n        resetTime: now + windowMs,\n      });\n    }\n    \n    return handler(request, context);\n  };\n}\n\n// Usage\nexport const POST = withRateLimit(async (request: NextRequest) => {\n  // Your API logic here\n}, 10, 60 * 1000); // 10 requests per minute\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-related-documentation",children:"\ud83d\udcda Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./setup",children:"Development Setup"})})," - Environment setup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./database",children:"Database & Prisma"})})," - Database operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./ui-framework",children:"UI Framework"})})," - Frontend integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./troubleshooting",children:"Troubleshooting"})})," - Common API issues"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Build robust, type-safe APIs with Next.js!"})," \ud83d\ude80"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);