"use strict";(self.webpackChunknuclear_docs=self.webpackChunknuclear_docs||[]).push([[52],{163:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"prisma-abstraction/folder","title":"Folder Organization","description":"The Folder module provides comprehensive type-safe CRUD operations and utility functions for managing hierarchical folder structures in the Nuclear application. This module handles folder creation, updates, deletion, and complex parent-child relationship queries.","source":"@site/docs/prisma-abstraction/folder.md","sourceDirName":"prisma-abstraction","slug":"/prisma-abstraction/folder","permalink":"/docs/prisma-abstraction/folder","draft":false,"unlisted":false,"editUrl":"https://github.com/nuclear-app/doc/tree/main/docs/prisma-abstraction/folder.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Block Management","permalink":"/docs/prisma-abstraction/block"},"next":{"title":"Quiz System","permalink":"/docs/prisma-abstraction/quiz"}}');var l=n(4848),d=n(8453);const i={sidebar_position:4},t="Folder Organization",s={},a=[{value:"Overview",id:"overview",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Core CRUD Functions",id:"core-crud-functions",level:3},{value:"<code>getFolderById(id: string): Promise&lt;Folder | null&gt;</code>",id:"getfolderbyidid-string-promisefolder--null",level:4},{value:"<code>getAllFolders(): Promise&lt;Folder[]&gt;</code>",id:"getallfolders-promisefolder",level:4},{value:"<code>createFolder(data: CreateFolderData): Promise&lt;Folder&gt;</code>",id:"createfolderdata-createfolderdata-promisefolder",level:4},{value:"<code>updateFolder(id: string, data: Partial&lt;Folder&gt;): Promise&lt;Folder&gt;</code>",id:"updatefolderid-string-data-partialfolder-promisefolder",level:4},{value:"<code>deleteFolder(id: string): Promise&lt;Folder&gt;</code>",id:"deletefolderid-string-promisefolder",level:4},{value:"Utility Functions",id:"utility-functions",level:3},{value:"<code>folderExists(id: string): Promise&lt;boolean&gt;</code>",id:"folderexistsid-string-promiseboolean",level:4},{value:"Relationship Queries",id:"relationship-queries",level:3},{value:"<code>getFolderBlocks(id: string): Promise&lt;Block[]&gt;</code>",id:"getfolderblocksid-string-promiseblock",level:4},{value:"<code>getFolderAuthor(id: string): Promise&lt;User | null&gt;</code>",id:"getfolderauthorid-string-promiseuser--null",level:4},{value:"<code>getFolderParent(id: string): Promise&lt;Folder | null&gt;</code>",id:"getfolderparentid-string-promisefolder--null",level:4},{value:"<code>getFolderChildren(id: string): Promise&lt;Folder[]&gt;</code>",id:"getfolderchildrenid-string-promisefolder",level:4},{value:"Data Types",id:"data-types",level:2},{value:"Folder Model",id:"folder-model",level:3},{value:"CreateFolderData",id:"createfolderdata",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Error Scenarios",id:"common-error-scenarios",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Complete Folder Management Workflow",id:"complete-folder-management-workflow",level:3},{value:"Hierarchical Folder Structure",id:"hierarchical-folder-structure",level:3},{value:"Folder Navigation and Analysis",id:"folder-navigation-and-analysis",level:3},{value:"Bulk Folder Operations",id:"bulk-folder-operations",level:3},{value:"Folder Reorganization",id:"folder-reorganization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Validate Folder Names",id:"1-validate-folder-names",level:3},{value:"2. Handle Parent-Child Relationships",id:"2-handle-parent-child-relationships",level:3},{value:"3. Use Efficient Queries",id:"3-use-efficient-queries",level:3},{value:"4. Implement Folder Validation",id:"4-implement-folder-validation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Related Modules",id:"related-modules",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(r.header,{children:(0,l.jsx)(r.h1,{id:"folder-organization",children:"Folder Organization"})}),"\n",(0,l.jsx)(r.p,{children:"The Folder module provides comprehensive type-safe CRUD operations and utility functions for managing hierarchical folder structures in the Nuclear application. This module handles folder creation, updates, deletion, and complex parent-child relationship queries."}),"\n",(0,l.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsxs)(r.p,{children:["The Folder module is located in ",(0,l.jsx)(r.code,{children:"lib/folder.ts"})," and provides functions for:"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"CRUD Operations"}),": Create, read, update, and delete folders"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Hierarchical Management"}),": Handle parent-child folder relationships"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Content Organization"}),": Manage blocks within folders"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"User Ownership"}),": Track folder ownership and permissions"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Validation"}),": Input validation and existence checks"]}),"\n"]}),"\n",(0,l.jsx)(r.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,l.jsx)(r.h3,{id:"core-crud-functions",children:"Core CRUD Functions"}),"\n",(0,l.jsx)(r.h4,{id:"getfolderbyidid-string-promisefolder--null",children:(0,l.jsx)(r.code,{children:"getFolderById(id: string): Promise<Folder | null>"})}),"\n",(0,l.jsx)(r.p,{children:"Get a folder by its unique ID."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const folder = await getFolderById('folder-123');\nif (folder) {\n  console.log(`Found folder: ${folder.name}`);\n}\n"})}),"\n",(0,l.jsx)(r.h4,{id:"getallfolders-promisefolder",children:(0,l.jsx)(r.code,{children:"getAllFolders(): Promise<Folder[]>"})}),"\n",(0,l.jsx)(r.p,{children:"Get all folders in the system."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const allFolders = await getAllFolders();\nconsole.log(`Total folders: ${allFolders.length}`);\n"})}),"\n",(0,l.jsx)(r.h4,{id:"createfolderdata-createfolderdata-promisefolder",children:(0,l.jsx)(r.code,{children:"createFolder(data: CreateFolderData): Promise<Folder>"})}),"\n",(0,l.jsx)(r.p,{children:"Create a new folder with validated input data."}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.code,{children:"data.name"})," (required): Folder name"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.code,{children:"data.authorId"})," (required): ID of the folder owner"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.code,{children:"data.parentId"})," (optional): ID of the parent folder"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.code,{children:"data.description"})," (optional): Folder description"]}),"\n"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const newFolder = await createFolder({\n  name: 'Nuclear Physics Course',\n  authorId: 'user-123',\n  parentId: 'folder-456',\n  description: 'Complete course on nuclear physics'\n});\n\nconsole.log(`Created folder: ${newFolder.id}`);\n"})}),"\n",(0,l.jsx)(r.h4,{id:"updatefolderid-string-data-partialfolder-promisefolder",children:(0,l.jsx)(r.code,{children:"updateFolder(id: string, data: Partial<Folder>): Promise<Folder>"})}),"\n",(0,l.jsx)(r.p,{children:"Update an existing folder's information."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const updatedFolder = await updateFolder('folder-123', {\n  name: 'Advanced Nuclear Physics Course',\n  description: 'Updated course description'\n});\n\nconsole.log(`Updated folder: ${updatedFolder.name}`);\n"})}),"\n",(0,l.jsx)(r.h4,{id:"deletefolderid-string-promisefolder",children:(0,l.jsx)(r.code,{children:"deleteFolder(id: string): Promise<Folder>"})}),"\n",(0,l.jsx)(r.p,{children:"Delete a folder by its ID."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const deletedFolder = await deleteFolder('folder-123');\nconsole.log(`Deleted folder: ${deletedFolder.name}`);\n"})}),"\n",(0,l.jsx)(r.h3,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,l.jsx)(r.h4,{id:"folderexistsid-string-promiseboolean",children:(0,l.jsx)(r.code,{children:"folderExists(id: string): Promise<boolean>"})}),"\n",(0,l.jsx)(r.p,{children:"Check if a folder exists by its ID."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"if (await folderExists('folder-123')) {\n  console.log('Folder exists');\n} else {\n  console.log('Folder not found');\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"relationship-queries",children:"Relationship Queries"}),"\n",(0,l.jsx)(r.h4,{id:"getfolderblocksid-string-promiseblock",children:(0,l.jsx)(r.code,{children:"getFolderBlocks(id: string): Promise<Block[]>"})}),"\n",(0,l.jsx)(r.p,{children:"Get all blocks contained in a folder."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const folderBlocks = await getFolderBlocks('folder-123');\nconsole.log(`Folder contains ${folderBlocks.length} blocks`);\n"})}),"\n",(0,l.jsx)(r.h4,{id:"getfolderauthorid-string-promiseuser--null",children:(0,l.jsx)(r.code,{children:"getFolderAuthor(id: string): Promise<User | null>"})}),"\n",(0,l.jsx)(r.p,{children:"Get the author/owner of a folder."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const author = await getFolderAuthor('folder-123');\nif (author) {\n  console.log(`Folder author: ${author.name}`);\n}\n"})}),"\n",(0,l.jsx)(r.h4,{id:"getfolderparentid-string-promisefolder--null",children:(0,l.jsx)(r.code,{children:"getFolderParent(id: string): Promise<Folder | null>"})}),"\n",(0,l.jsx)(r.p,{children:"Get the parent folder of a folder."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const parent = await getFolderParent('folder-123');\nif (parent) {\n  console.log(`Parent folder: ${parent.name}`);\n}\n"})}),"\n",(0,l.jsx)(r.h4,{id:"getfolderchildrenid-string-promisefolder",children:(0,l.jsx)(r.code,{children:"getFolderChildren(id: string): Promise<Folder[]>"})}),"\n",(0,l.jsx)(r.p,{children:"Get all child folders of a folder."}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"const children = await getFolderChildren('folder-123');\nconsole.log(`Folder has ${children.length} child folders`);\n"})}),"\n",(0,l.jsx)(r.h2,{id:"data-types",children:"Data Types"}),"\n",(0,l.jsx)(r.h3,{id:"folder-model",children:"Folder Model"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"interface Folder {\n  id: string;\n  name: string;\n  description?: string;\n  authorId: string;\n  parentId?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"createfolderdata",children:"CreateFolderData"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"interface CreateFolderData {\n  name: string;\n  authorId: string;\n  parentId?: string;\n  description?: string;\n}\n"})}),"\n",(0,l.jsx)(r.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,l.jsx)(r.p,{children:"The Folder module defines a custom error class for consistent error handling:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"class FolderError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FolderError';\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"common-error-scenarios",children:"Common Error Scenarios"}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsx)(r.li,{children:(0,l.jsx)(r.strong,{children:"Folder Not Found"})}),"\n"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"try {\n  const folder = await getFolderById('non-existent-id');\n  if (!folder) {\n    throw new FolderError('Folder not found');\n  }\n} catch (error) {\n  if (error instanceof FolderError) {\n    console.error('Folder error:', error.message);\n  }\n}\n"})}),"\n",(0,l.jsxs)(r.ol,{start:"2",children:["\n",(0,l.jsx)(r.li,{children:(0,l.jsx)(r.strong,{children:"Invalid Parent Folder"})}),"\n"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"try {\n  const folder = await createFolder({\n    name: 'Test Folder',\n    authorId: 'user-123',\n    parentId: 'non-existent-parent'\n  });\n} catch (error) {\n  if (error instanceof FolderError) {\n    console.error('Parent folder error:', error.message);\n  }\n}\n"})}),"\n",(0,l.jsxs)(r.ol,{start:"3",children:["\n",(0,l.jsx)(r.li,{children:(0,l.jsx)(r.strong,{children:"Circular Reference"})}),"\n"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"try {\n  // Attempting to set a child as its own parent\n  await updateFolder('folder-123', {\n    parentId: 'folder-123'\n  });\n} catch (error) {\n  if (error instanceof FolderError) {\n    console.error('Circular reference error:', error.message);\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,l.jsx)(r.h3,{id:"complete-folder-management-workflow",children:"Complete Folder Management Workflow"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"async function manageFolder() {\n  try {\n    // Create a root folder\n    const rootFolder = await createFolder({\n      name: 'Nuclear Physics',\n      authorId: 'user-123',\n      description: 'Main course folder'\n    });\n\n    // Create a subfolder\n    const subFolder = await createFolder({\n      name: 'Basic Concepts',\n      authorId: 'user-123',\n      parentId: rootFolder.id,\n      description: 'Introduction to nuclear physics'\n    });\n\n    // Update folder information\n    const updatedFolder = await updateFolder(subFolder.id, {\n      name: 'Fundamental Concepts',\n      description: 'Updated description for fundamental concepts'\n    });\n\n    // Get folder relationships\n    const author = await getFolderAuthor(updatedFolder.id);\n    const parent = await getFolderParent(updatedFolder.id);\n    const children = await getFolderChildren(updatedFolder.id);\n    const blocks = await getFolderBlocks(updatedFolder.id);\n\n    console.log(`Folder \"${updatedFolder.name}\" by ${author?.name}`);\n    console.log(`Parent: ${parent?.name}, Children: ${children.length}, Blocks: ${blocks.length}`);\n\n    // Check if folder exists before operations\n    if (await folderExists(updatedFolder.id)) {\n      const folder = await getFolderById(updatedFolder.id);\n      console.log(`Folder created: ${folder?.createdAt}`);\n    }\n\n  } catch (error) {\n    if (error instanceof FolderError) {\n      console.error('Folder management error:', error.message);\n    }\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"hierarchical-folder-structure",children:"Hierarchical Folder Structure"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"async function createHierarchicalStructure() {\n  try {\n    // Create main course folder\n    const courseFolder = await createFolder({\n      name: 'Nuclear Physics Course',\n      authorId: 'user-123',\n      description: 'Complete nuclear physics curriculum'\n    });\n\n    // Create module folders\n    const modules = [\n      { name: 'Module 1: Introduction', description: 'Basic concepts and history' },\n      { name: 'Module 2: Atomic Structure', description: 'Understanding atomic nuclei' },\n      { name: 'Module 3: Nuclear Reactions', description: 'Fusion and fission processes' },\n      { name: 'Module 4: Applications', description: 'Real-world applications' }\n    ];\n\n    const moduleFolders = [];\n    for (const module of modules) {\n      const folder = await createFolder({\n        name: module.name,\n        authorId: 'user-123',\n        parentId: courseFolder.id,\n        description: module.description\n      });\n      moduleFolders.push(folder);\n    }\n\n    // Create sub-modules for each module\n    for (const moduleFolder of moduleFolders) {\n      const subModules = [\n        { name: 'Theory', description: 'Theoretical foundations' },\n        { name: 'Practice', description: 'Practical exercises' },\n        { name: 'Assessment', description: 'Quizzes and tests' }\n      ];\n\n      for (const subModule of subModules) {\n        await createFolder({\n          name: subModule.name,\n          authorId: 'user-123',\n          parentId: moduleFolder.id,\n          description: subModule.description\n        });\n      }\n    }\n\n    console.log(`Created hierarchical structure with ${moduleFolders.length} main modules`);\n\n  } catch (error) {\n    if (error instanceof FolderError) {\n      console.error('Hierarchy creation error:', error.message);\n    }\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"folder-navigation-and-analysis",children:"Folder Navigation and Analysis"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"async function analyzeFolderStructure(folderId: string) {\n  try {\n    const folder = await getFolderById(folderId);\n    if (!folder) {\n      throw new FolderError('Folder not found');\n    }\n\n    // Get all related data\n    const [author, parent, children, blocks] = await Promise.all([\n      getFolderAuthor(folderId),\n      getFolderParent(folderId),\n      getFolderChildren(folderId),\n      getFolderBlocks(folderId)\n    ]);\n\n    // Analyze structure\n    const analysis = {\n      folder: {\n        id: folder.id,\n        name: folder.name,\n        description: folder.description,\n        createdAt: folder.createdAt\n      },\n      relationships: {\n        author: author?.name,\n        parent: parent?.name,\n        childrenCount: children.length,\n        blocksCount: blocks.length\n      },\n      children: children.map(child => ({\n        id: child.id,\n        name: child.name,\n        description: child.description\n      })),\n      blocks: blocks.map(block => ({\n        id: block.id,\n        title: block.title,\n        published: block.published\n      }))\n    };\n\n    console.log('Folder Analysis:', analysis);\n    return analysis;\n\n  } catch (error) {\n    if (error instanceof FolderError) {\n      console.error('Analysis error:', error.message);\n    }\n    throw error;\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"bulk-folder-operations",children:"Bulk Folder Operations"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"async function bulkFolderOperations() {\n  try {\n    // Get all folders\n    const allFolders = await getAllFolders();\n    \n    // Analyze folder hierarchy\n    const rootFolders = allFolders.filter(folder => !folder.parentId);\n    const subFolders = allFolders.filter(folder => folder.parentId);\n    \n    console.log(`Total folders: ${allFolders.length}`);\n    console.log(`Root folders: ${rootFolders.length}`);\n    console.log(`Sub-folders: ${subFolders.length}`);\n\n    // Analyze each root folder\n    for (const rootFolder of rootFolders) {\n      const children = await getFolderChildren(rootFolder.id);\n      const blocks = await getFolderBlocks(rootFolder.id);\n      \n      console.log(`${rootFolder.name}: ${children.length} children, ${blocks.length} blocks`);\n    }\n\n    // Get folders by author\n    const authorId = 'user-123';\n    const authorFolders = allFolders.filter(folder => folder.authorId === authorId);\n    console.log(`Author ${authorId} has ${authorFolders.length} folders`);\n\n  } catch (error) {\n    if (error instanceof FolderError) {\n      console.error('Bulk operation error:', error.message);\n    }\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"folder-reorganization",children:"Folder Reorganization"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"async function reorganizeFolders() {\n  try {\n    // Get all folders\n    const allFolders = await getAllFolders();\n    \n    // Find folders that need reorganization\n    const orphanedFolders = allFolders.filter(folder => \n      folder.parentId && !allFolders.find(f => f.id === folder.parentId)\n    );\n\n    console.log(`Found ${orphanedFolders.length} orphaned folders`);\n\n    // Move orphaned folders to root level\n    for (const orphanedFolder of orphanedFolders) {\n      await updateFolder(orphanedFolder.id, {\n        parentId: undefined\n      });\n      console.log(`Moved \"${orphanedFolder.name}\" to root level`);\n    }\n\n    // Consolidate empty folders\n    for (const folder of allFolders) {\n      const [children, blocks] = await Promise.all([\n        getFolderChildren(folder.id),\n        getFolderBlocks(folder.id)\n      ]);\n\n      if (children.length === 0 && blocks.length === 0) {\n        console.log(`Empty folder found: ${folder.name}`);\n        // Optionally delete empty folders\n        // await deleteFolder(folder.id);\n      }\n    }\n\n  } catch (error) {\n    if (error instanceof FolderError) {\n      console.error('Reorganization error:', error.message);\n    }\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(r.h3,{id:"1-validate-folder-names",children:"1. Validate Folder Names"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"// \u2705 Good - Validate folder name quality\nif (!data.name.trim()) {\n  throw new FolderError('Folder name cannot be empty');\n}\n\nif (data.name.length > 100) {\n  throw new FolderError('Folder name too long');\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"2-handle-parent-child-relationships",children:"2. Handle Parent-Child Relationships"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"// \u2705 Good - Check parent exists before creating child\nif (parentId && !await folderExists(parentId)) {\n  throw new FolderError('Parent folder does not exist');\n}\n\n// \u2705 Good - Prevent circular references\nasync function validateParentChild(parentId: string, childId: string) {\n  if (parentId === childId) {\n    throw new FolderError('Folder cannot be its own parent');\n  }\n  \n  // Check if child is ancestor of parent\n  let current = parentId;\n  while (current) {\n    const parent = await getFolderById(current);\n    if (parent?.parentId === childId) {\n      throw new FolderError('Circular reference detected');\n    }\n    current = parent?.parentId;\n  }\n}\n"})}),"\n",(0,l.jsx)(r.h3,{id:"3-use-efficient-queries",children:"3. Use Efficient Queries"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"// \u2705 Good - Use Promise.all for parallel queries\nconst [author, parent, children, blocks] = await Promise.all([\n  getFolderAuthor(folderId),\n  getFolderParent(folderId),\n  getFolderChildren(folderId),\n  getFolderBlocks(folderId)\n]);\n\n// \u274c Avoid - Sequential queries\nconst author = await getFolderAuthor(folderId);\nconst parent = await getFolderParent(folderId);\nconst children = await getFolderChildren(folderId);\nconst blocks = await getFolderBlocks(folderId);\n"})}),"\n",(0,l.jsx)(r.h3,{id:"4-implement-folder-validation",children:"4. Implement Folder Validation"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-typescript",children:"// \u2705 Good - Validate folder structure\nasync function validateFolderStructure(folderId: string) {\n  const folder = await getFolderById(folderId);\n  if (!folder) {\n    throw new FolderError('Folder not found');\n  }\n\n  // Check for circular references\n  if (folder.parentId) {\n    await validateParentChild(folder.parentId, folderId);\n  }\n\n  return true;\n}\n"})}),"\n",(0,l.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Indexing"}),": Ensure authorId and parentId fields are indexed"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Batch Operations"}),": Use ",(0,l.jsx)(r.code,{children:"getAllFolders()"})," for bulk operations"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Caching"}),": Consider caching folder hierarchy data"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Pagination"}),": For large folder lists, implement pagination"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Lazy Loading"}),": Load child folders only when needed"]}),"\n"]}),"\n",(0,l.jsx)(r.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.a,{href:"./user",children:"User Management"})})," - Manage folder owners"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.a,{href:"./block",children:"Block Management"})})," - Organize blocks in folders"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.a,{href:"./quiz",children:"Quiz System"})})," - Create quiz folders"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.a,{href:"./topic",children:"Topic Management"})})," - Organize topics in folders"]}),"\n"]}),"\n",(0,l.jsx)(r.hr,{}),"\n",(0,l.jsxs)(r.p,{children:["Next: ",(0,l.jsx)(r.a,{href:"./quiz",children:"Quiz System"})," - Learn how to create and manage quizzes with topic associations."]})]})}function h(e={}){const{wrapper:r}={...(0,d.R)(),...e.components};return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>t});var o=n(6540);const l={},d=o.createContext(l);function i(e){const r=o.useContext(d);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function t(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),o.createElement(d.Provider,{value:r},e.children)}}}]);