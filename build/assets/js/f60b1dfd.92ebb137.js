"use strict";(self.webpackChunknuclear_docs=self.webpackChunknuclear_docs||[]).push([[304],{3924:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"prisma-abstraction/points-update","title":"Points System","description":"The Points Update module provides comprehensive type-safe CRUD operations and utility functions for managing points and progress tracking in the Nuclear application. This module handles points creation, updates, deletion, and advanced aggregation and analysis capabilities.","source":"@site/docs/prisma-abstraction/points-update.md","sourceDirName":"prisma-abstraction","slug":"/prisma-abstraction/points-update","permalink":"/docs/prisma-abstraction/points-update","draft":false,"unlisted":false,"editUrl":"https://github.com/nuclear-app/doc/tree/main/docs/prisma-abstraction/points-update.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Fill-in-the-Blank","permalink":"/docs/prisma-abstraction/fill-in-the-blank"},"next":{"title":"Development Guide","permalink":"/docs/development/"}}');var o=t(4848),i=t(8453);const a={sidebar_position:9},r="Points System",d={},l=[{value:"Overview",id:"overview",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Core CRUD Functions",id:"core-crud-functions",level:3},{value:"<code>getPointsUpdateById(id: string): Promise&lt;PointsUpdate | null&gt;</code>",id:"getpointsupdatebyidid-string-promisepointsupdate--null",level:4},{value:"<code>getAllPointsUpdates(): Promise&lt;PointsUpdate[]&gt;</code>",id:"getallpointsupdates-promisepointsupdate",level:4},{value:"<code>createPointsUpdate(data: CreatePointsUpdateData): Promise&lt;PointsUpdate&gt;</code>",id:"createpointsupdatedata-createpointsupdatedata-promisepointsupdate",level:4},{value:"<code>updatePointsUpdate(id: string, data: Partial&lt;PointsUpdate&gt;): Promise&lt;PointsUpdate&gt;</code>",id:"updatepointsupdateid-string-data-partialpointsupdate-promisepointsupdate",level:4},{value:"<code>deletePointsUpdate(id: string): Promise&lt;PointsUpdate&gt;</code>",id:"deletepointsupdateid-string-promisepointsupdate",level:4},{value:"Utility Functions",id:"utility-functions",level:3},{value:"<code>pointsUpdateExists(id: string): Promise&lt;boolean&gt;</code>",id:"pointsupdateexistsid-string-promiseboolean",level:4},{value:"Relationship Queries",id:"relationship-queries",level:3},{value:"<code>getPointsUpdateBlock(id: string): Promise&lt;Block | null&gt;</code>",id:"getpointsupdateblockid-string-promiseblock--null",level:4},{value:"<code>getPointsUpdatesByBlock(blockId: string): Promise&lt;PointsUpdate[]&gt;</code>",id:"getpointsupdatesbyblockblockid-string-promisepointsupdate",level:4},{value:"Advanced Functions",id:"advanced-functions",level:3},{value:"<code>getPointsUpdateWithRelations(id: string)</code>",id:"getpointsupdatewithrelationsid-string",level:4},{value:"Aggregation Functions",id:"aggregation-functions",level:3},{value:"<code>getTotalPointsForBlock(blockId: string): Promise&lt;number&gt;</code>",id:"gettotalpointsforblockblockid-string-promisenumber",level:4},{value:"<code>getPointsUpdatesByDateRange(startDate: Date, endDate: Date): Promise&lt;PointsUpdate[]&gt;</code>",id:"getpointsupdatesbydaterangestartdate-date-enddate-date-promisepointsupdate",level:4},{value:"<code>getPointsUpdatesByMinPoints(minPoints: number): Promise&lt;PointsUpdate[]&gt;</code>",id:"getpointsupdatesbyminpointsminpoints-number-promisepointsupdate",level:4},{value:"<code>getLatestPointsUpdateForBlock(blockId: string): Promise&lt;PointsUpdate | null&gt;</code>",id:"getlatestpointsupdateforblockblockid-string-promisepointsupdate--null",level:4},{value:"<code>getPointsUpdatesForBlockOrdered(blockId: string, order: &#39;asc&#39; | &#39;desc&#39;): Promise&lt;PointsUpdate[]&gt;</code>",id:"getpointsupdatesforblockorderedblockid-string-order-asc--desc-promisepointsupdate",level:4},{value:"Data Types",id:"data-types",level:2},{value:"PointsUpdate Model",id:"pointsupdate-model",level:3},{value:"CreatePointsUpdateData",id:"createpointsupdatedata",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Error Scenarios",id:"common-error-scenarios",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Complete Points Management Workflow",id:"complete-points-management-workflow",level:3},{value:"Progress Tracking System",id:"progress-tracking-system",level:3},{value:"Block Performance Analysis",id:"block-performance-analysis",level:3},{value:"Time-Based Analytics",id:"time-based-analytics",level:3},{value:"Gamification System",id:"gamification-system",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Validate Points Values",id:"1-validate-points-values",level:3},{value:"2. Handle Relationships Properly",id:"2-handle-relationships-properly",level:3},{value:"3. Use Efficient Queries",id:"3-use-efficient-queries",level:3},{value:"4. Implement Points Validation",id:"4-implement-points-validation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Related Modules",id:"related-modules",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"points-system",children:"Points System"})}),"\n",(0,o.jsx)(n.p,{children:"The Points Update module provides comprehensive type-safe CRUD operations and utility functions for managing points and progress tracking in the Nuclear application. This module handles points creation, updates, deletion, and advanced aggregation and analysis capabilities."}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.p,{children:["The Points Update module is located in ",(0,o.jsx)(n.code,{children:"lib/pointsUpdate.ts"})," and provides functions for:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CRUD Operations"}),": Create, read, update, and delete points updates"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Block Associations"}),": Link points to specific content blocks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Aggregation Functions"}),": Calculate totals, averages, and progress metrics"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Date Range Queries"}),": Filter points by time periods"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Progress Tracking"}),": Monitor user advancement through content"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Validation"}),": Input validation and existence checks"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,o.jsx)(n.h3,{id:"core-crud-functions",children:"Core CRUD Functions"}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdatebyidid-string-promisepointsupdate--null",children:(0,o.jsx)(n.code,{children:"getPointsUpdateById(id: string): Promise<PointsUpdate | null>"})}),"\n",(0,o.jsx)(n.p,{children:"Get a points update by its unique ID."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const pointsUpdate = await getPointsUpdateById('points-123');\nif (pointsUpdate) {\n  console.log(`Found points update: ${pointsUpdate.points} points`);\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"getallpointsupdates-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"getAllPointsUpdates(): Promise<PointsUpdate[]>"})}),"\n",(0,o.jsx)(n.p,{children:"Get all points updates in the system."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const allPointsUpdates = await getAllPointsUpdates();\nconsole.log(`Total points updates: ${allPointsUpdates.length}`);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"createpointsupdatedata-createpointsupdatedata-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"createPointsUpdate(data: CreatePointsUpdateData): Promise<PointsUpdate>"})}),"\n",(0,o.jsx)(n.p,{children:"Create a new points update with validated input data."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"data.points"})," (required): Number of points earned"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"data.blockId"})," (optional): ID of the associated block"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"data.reason"})," (optional): Reason for earning points"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"data.userId"})," (optional): ID of the user who earned points"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const newPointsUpdate = await createPointsUpdate({\n  points: 25,\n  blockId: 'block-123',\n  reason: 'Completed quiz successfully',\n  userId: 'user-456'\n});\n\nconsole.log(`Created points update: ${newPointsUpdate.id}`);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"updatepointsupdateid-string-data-partialpointsupdate-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"updatePointsUpdate(id: string, data: Partial<PointsUpdate>): Promise<PointsUpdate>"})}),"\n",(0,o.jsx)(n.p,{children:"Update an existing points update's information."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const updatedPointsUpdate = await updatePointsUpdate('points-123', {\n  points: 30,\n  reason: 'Bonus points for perfect score'\n});\n\nconsole.log(`Updated points update: ${updatedPointsUpdate.points} points`);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"deletepointsupdateid-string-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"deletePointsUpdate(id: string): Promise<PointsUpdate>"})}),"\n",(0,o.jsx)(n.p,{children:"Delete a points update by its ID."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const deletedPointsUpdate = await deletePointsUpdate('points-123');\nconsole.log(`Deleted points update: ${deletedPointsUpdate.points} points`);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,o.jsx)(n.h4,{id:"pointsupdateexistsid-string-promiseboolean",children:(0,o.jsx)(n.code,{children:"pointsUpdateExists(id: string): Promise<boolean>"})}),"\n",(0,o.jsx)(n.p,{children:"Check if a points update exists by its ID."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"if (await pointsUpdateExists('points-123')) {\n  console.log('Points update exists');\n} else {\n  console.log('Points update not found');\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"relationship-queries",children:"Relationship Queries"}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdateblockid-string-promiseblock--null",children:(0,o.jsx)(n.code,{children:"getPointsUpdateBlock(id: string): Promise<Block | null>"})}),"\n",(0,o.jsx)(n.p,{children:"Get the block associated with a points update."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const block = await getPointsUpdateBlock('points-123');\nif (block) {\n  console.log(`Points update block: ${block.title}`);\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdatesbyblockblockid-string-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"getPointsUpdatesByBlock(blockId: string): Promise<PointsUpdate[]>"})}),"\n",(0,o.jsx)(n.p,{children:"Get all points updates for a specific block."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const blockPointsUpdates = await getPointsUpdatesByBlock('block-123');\nconsole.log(`Block has ${blockPointsUpdates.length} points updates`);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-functions",children:"Advanced Functions"}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdatewithrelationsid-string",children:(0,o.jsx)(n.code,{children:"getPointsUpdateWithRelations(id: string)"})}),"\n",(0,o.jsx)(n.p,{children:"Get a points update with all related data."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const pointsUpdateWithRelations = await getPointsUpdateWithRelations('points-123');\nconsole.log(`Points: ${pointsUpdateWithRelations.points}`);\nconsole.log(`Block: ${pointsUpdateWithRelations.block?.title}`);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"aggregation-functions",children:"Aggregation Functions"}),"\n",(0,o.jsx)(n.h4,{id:"gettotalpointsforblockblockid-string-promisenumber",children:(0,o.jsx)(n.code,{children:"getTotalPointsForBlock(blockId: string): Promise<number>"})}),"\n",(0,o.jsx)(n.p,{children:"Get the total points for a block."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const totalPoints = await getTotalPointsForBlock('block-123');\nconsole.log(`Total points for block: ${totalPoints}`);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdatesbydaterangestartdate-date-enddate-date-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"getPointsUpdatesByDateRange(startDate: Date, endDate: Date): Promise<PointsUpdate[]>"})}),"\n",(0,o.jsx)(n.p,{children:"Get all points updates in a date range."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const startDate = new Date('2024-01-01');\nconst endDate = new Date('2024-01-31');\nconst monthlyPoints = await getPointsUpdatesByDateRange(startDate, endDate);\nconsole.log(`Points updates in January: ${monthlyPoints.length}`);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdatesbyminpointsminpoints-number-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"getPointsUpdatesByMinPoints(minPoints: number): Promise<PointsUpdate[]>"})}),"\n",(0,o.jsx)(n.p,{children:"Get all points updates with at least a certain number of points."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const highValueUpdates = await getPointsUpdatesByMinPoints(50);\nconsole.log(`Found ${highValueUpdates.length} updates with 50+ points`);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"getlatestpointsupdateforblockblockid-string-promisepointsupdate--null",children:(0,o.jsx)(n.code,{children:"getLatestPointsUpdateForBlock(blockId: string): Promise<PointsUpdate | null>"})}),"\n",(0,o.jsx)(n.p,{children:"Get the latest points update for a block."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const latestUpdate = await getLatestPointsUpdateForBlock('block-123');\nif (latestUpdate) {\n  console.log(`Latest update: ${latestUpdate.points} points on ${latestUpdate.createdAt}`);\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"getpointsupdatesforblockorderedblockid-string-order-asc--desc-promisepointsupdate",children:(0,o.jsx)(n.code,{children:"getPointsUpdatesForBlockOrdered(blockId: string, order: 'asc' | 'desc'): Promise<PointsUpdate[]>"})}),"\n",(0,o.jsx)(n.p,{children:"Get all points updates for a block, ordered by date."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const chronologicalUpdates = await getPointsUpdatesForBlockOrdered('block-123', 'asc');\nconsole.log(`Chronological updates: ${chronologicalUpdates.length}`);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"data-types",children:"Data Types"}),"\n",(0,o.jsx)(n.h3,{id:"pointsupdate-model",children:"PointsUpdate Model"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface PointsUpdate {\n  id: string;\n  points: number;\n  blockId?: string;\n  reason?: string;\n  userId?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"createpointsupdatedata",children:"CreatePointsUpdateData"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface CreatePointsUpdateData {\n  points: number;\n  blockId?: string;\n  reason?: string;\n  userId?: string;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.p,{children:"The Points Update module defines a custom error class for consistent error handling:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"class PointsUpdateError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PointsUpdateError';\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"common-error-scenarios",children:"Common Error Scenarios"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Points Update Not Found"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"try {\n  const pointsUpdate = await getPointsUpdateById('non-existent-id');\n  if (!pointsUpdate) {\n    throw new PointsUpdateError('Points update not found');\n  }\n} catch (error) {\n  if (error instanceof PointsUpdateError) {\n    console.error('Points update error:', error.message);\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Invalid Points Value"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"try {\n  const pointsUpdate = await createPointsUpdate({\n    points: -10, // Negative points\n    blockId: 'block-123'\n  });\n} catch (error) {\n  if (error instanceof PointsUpdateError) {\n    console.error('Points validation error:', error.message);\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Invalid Block Association"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"try {\n  const pointsUpdate = await createPointsUpdate({\n    points: 25,\n    blockId: 'non-existent-block'\n  });\n} catch (error) {\n  if (error instanceof PointsUpdateError) {\n    console.error('Block validation error:', error.message);\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,o.jsx)(n.h3,{id:"complete-points-management-workflow",children:"Complete Points Management Workflow"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"async function managePoints() {\n  try {\n    // Create a new points update\n    const newPointsUpdate = await createPointsUpdate({\n      points: 50,\n      blockId: 'block-123',\n      reason: 'Completed advanced quiz with perfect score',\n      userId: 'user-456'\n    });\n\n    // Update points information\n    const updatedPointsUpdate = await updatePointsUpdate(newPointsUpdate.id, {\n      points: 75,\n      reason: 'Bonus points for perfect score and time bonus'\n    });\n\n    // Get points update relationships\n    const block = await getPointsUpdateBlock(updatedPointsUpdate.id);\n\n    console.log(`Points: ${updatedPointsUpdate.points}`);\n    console.log(`Block: ${block?.title}, Reason: ${updatedPointsUpdate.reason}`);\n    console.log(`User: ${updatedPointsUpdate.userId}`);\n\n    // Check if points update exists before operations\n    if (await pointsUpdateExists(updatedPointsUpdate.id)) {\n      const pointsUpdate = await getPointsUpdateById(updatedPointsUpdate.id);\n      console.log(`Points update created: ${pointsUpdate?.createdAt}`);\n    }\n\n  } catch (error) {\n    if (error instanceof PointsUpdateError) {\n      console.error('Points management error:', error.message);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"progress-tracking-system",children:"Progress Tracking System"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"async function trackUserProgress(userId: string) {\n  try {\n    // Get all points updates for the user\n    const allPointsUpdates = await getAllPointsUpdates();\n    const userPointsUpdates = allPointsUpdates.filter(update => update.userId === userId);\n\n    // Calculate progress metrics\n    const progress = {\n      totalPoints: userPointsUpdates.reduce((sum, update) => sum + update.points, 0),\n      totalUpdates: userPointsUpdates.length,\n      averagePoints: 0,\n      recentActivity: 0,\n      blocksCompleted: new Set()\n    };\n\n    // Calculate averages and recent activity\n    if (userPointsUpdates.length > 0) {\n      progress.averagePoints = progress.totalPoints / userPointsUpdates.length;\n    }\n\n    // Get recent activity (last 7 days)\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    \n    const recentUpdates = userPointsUpdates.filter(update => \n      update.createdAt >= oneWeekAgo\n    );\n    progress.recentActivity = recentUpdates.reduce((sum, update) => sum + update.points, 0);\n\n    // Count unique blocks\n    userPointsUpdates.forEach(update => {\n      if (update.blockId) {\n        progress.blocksCompleted.add(update.blockId);\n      }\n    });\n\n    console.log('User Progress Report:', {\n      ...progress,\n      blocksCompleted: progress.blocksCompleted.size\n    });\n\n    return progress;\n\n  } catch (error) {\n    if (error instanceof PointsUpdateError) {\n      console.error('Progress tracking error:', error.message);\n    }\n    throw error;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"block-performance-analysis",children:"Block Performance Analysis"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"async function analyzeBlockPerformance(blockId: string) {\n  try {\n    // Get all points updates for the block\n    const blockPointsUpdates = await getPointsUpdatesByBlock(blockId);\n    \n    // Calculate performance metrics\n    const analysis = {\n      totalPoints: blockPointsUpdates.reduce((sum, update) => sum + update.points, 0),\n      totalUpdates: blockPointsUpdates.length,\n      averagePoints: 0,\n      highestPoints: 0,\n      lowestPoints: Infinity,\n      recentActivity: 0,\n      uniqueUsers: new Set()\n    };\n\n    // Calculate statistics\n    if (blockPointsUpdates.length > 0) {\n      analysis.averagePoints = analysis.totalPoints / blockPointsUpdates.length;\n      analysis.highestPoints = Math.max(...blockPointsUpdates.map(u => u.points));\n      analysis.lowestPoints = Math.min(...blockPointsUpdates.map(u => u.points));\n    }\n\n    // Get recent activity (last 30 days)\n    const oneMonthAgo = new Date();\n    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n    \n    const recentUpdates = blockPointsUpdates.filter(update => \n      update.createdAt >= oneMonthAgo\n    );\n    analysis.recentActivity = recentUpdates.reduce((sum, update) => sum + update.points, 0);\n\n    // Count unique users\n    blockPointsUpdates.forEach(update => {\n      if (update.userId) {\n        analysis.uniqueUsers.add(update.userId);\n      }\n    });\n\n    console.log('Block Performance Analysis:', {\n      ...analysis,\n      uniqueUsers: analysis.uniqueUsers.size\n    });\n\n    // Get latest activity\n    const latestUpdate = await getLatestPointsUpdateForBlock(blockId);\n    if (latestUpdate) {\n      console.log(`Latest activity: ${latestUpdate.points} points on ${latestUpdate.createdAt}`);\n    }\n\n    return analysis;\n\n  } catch (error) {\n    if (error instanceof PointsUpdateError) {\n      console.error('Performance analysis error:', error.message);\n    }\n    throw error;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"time-based-analytics",children:"Time-Based Analytics"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"async function timeBasedAnalytics() {\n  try {\n    // Get points updates for different time periods\n    const now = new Date();\n    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    const threeMonthsAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\n\n    const [weeklyUpdates, monthlyUpdates, quarterlyUpdates] = await Promise.all([\n      getPointsUpdatesByDateRange(oneWeekAgo, now),\n      getPointsUpdatesByDateRange(oneMonthAgo, now),\n      getPointsUpdatesByDateRange(threeMonthsAgo, now)\n    ]);\n\n    // Calculate totals for each period\n    const analytics = {\n      weekly: {\n        totalPoints: weeklyUpdates.reduce((sum, update) => sum + update.points, 0),\n        totalUpdates: weeklyUpdates.length\n      },\n      monthly: {\n        totalPoints: monthlyUpdates.reduce((sum, update) => sum + update.points, 0),\n        totalUpdates: monthlyUpdates.length\n      },\n      quarterly: {\n        totalPoints: quarterlyUpdates.reduce((sum, update) => sum + update.points, 0),\n        totalUpdates: quarterlyUpdates.length\n      }\n    };\n\n    console.log('Time-Based Analytics:', analytics);\n\n    // Find high-value updates\n    const highValueUpdates = await getPointsUpdatesByMinPoints(100);\n    console.log(`High-value updates (100+ points): ${highValueUpdates.length}`);\n\n    // Analyze trends\n    const weeklyAverage = analytics.weekly.totalPoints / 7;\n    const monthlyAverage = analytics.monthly.totalPoints / 30;\n    \n    console.log(`Daily average (week): ${weeklyAverage.toFixed(2)} points`);\n    console.log(`Daily average (month): ${monthlyAverage.toFixed(2)} points`);\n\n    return analytics;\n\n  } catch (error) {\n    if (error instanceof PointsUpdateError) {\n      console.error('Time-based analytics error:', error.message);\n    }\n    throw error;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"gamification-system",children:"Gamification System"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"async function gamificationSystem() {\n  try {\n    // Get all points updates\n    const allPointsUpdates = await getAllPointsUpdates();\n    \n    // Calculate leaderboard\n    const userScores = {};\n    allPointsUpdates.forEach(update => {\n      if (update.userId) {\n        userScores[update.userId] = (userScores[update.userId] || 0) + update.points;\n      }\n    });\n\n    // Sort users by total points\n    const leaderboard = Object.entries(userScores)\n      .map(([userId, points]) => ({ userId, points }))\n      .sort((a, b) => b.points - a.points)\n      .slice(0, 10);\n\n    console.log('Top 10 Leaderboard:');\n    leaderboard.forEach((entry, index) => {\n      console.log(`${index + 1}. User ${entry.userId}: ${entry.points} points`);\n    });\n\n    // Award achievements\n    const achievements = [];\n    for (const [userId, totalPoints] of Object.entries(userScores)) {\n      if (totalPoints >= 1000) {\n        achievements.push({ userId, achievement: 'Master Learner', points: totalPoints });\n      } else if (totalPoints >= 500) {\n        achievements.push({ userId, achievement: 'Advanced Learner', points: totalPoints });\n      } else if (totalPoints >= 100) {\n        achievements.push({ userId, achievement: 'Beginner Learner', points: totalPoints });\n      }\n    }\n\n    console.log('Achievements Awarded:', achievements);\n\n    // Create bonus points for achievements\n    for (const achievement of achievements) {\n      const bonusPoints = achievement.points >= 1000 ? 100 : achievement.points >= 500 ? 50 : 25;\n      \n      await createPointsUpdate({\n        points: bonusPoints,\n        reason: `Achievement bonus: ${achievement.achievement}`,\n        userId: achievement.userId\n      });\n      \n      console.log(`Awarded ${bonusPoints} bonus points to user ${achievement.userId}`);\n    }\n\n  } catch (error) {\n    if (error instanceof PointsUpdateError) {\n      console.error('Gamification system error:', error.message);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"1-validate-points-values",children:"1. Validate Points Values"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Validate points are positive\nif (data.points < 0) {\n  throw new PointsUpdateError('Points cannot be negative');\n}\n\nif (data.points > 10000) {\n  throw new PointsUpdateError('Points value too high');\n}\n\n// \u2705 Good - Validate points are integers\nif (!Number.isInteger(data.points)) {\n  throw new PointsUpdateError('Points must be a whole number');\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"2-handle-relationships-properly",children:"2. Handle Relationships Properly"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Check block exists before creating points update\nif (blockId && !await blockExists(blockId)) {\n  throw new PointsUpdateError('Block does not exist');\n}\n\n// \u2705 Good - Check user exists before creating points update\nif (userId && !await userExists(userId)) {\n  throw new PointsUpdateError('User does not exist');\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"3-use-efficient-queries",children:"3. Use Efficient Queries"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Use Promise.all for parallel queries\nconst [block, totalPoints] = await Promise.all([\n  getPointsUpdateBlock(pointsUpdateId),\n  getTotalPointsForBlock(blockId)\n]);\n\n// \u274c Avoid - Sequential queries\nconst block = await getPointsUpdateBlock(pointsUpdateId);\nconst totalPoints = await getTotalPointsForBlock(blockId);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"4-implement-points-validation",children:"4. Implement Points Validation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Validate points update completeness\nasync function validatePointsUpdate(pointsUpdateId: string) {\n  const pointsUpdate = await getPointsUpdateById(pointsUpdateId);\n  if (!pointsUpdate) {\n    throw new PointsUpdateError('Points update not found');\n  }\n\n  if (pointsUpdate.points < 0) {\n    throw new PointsUpdateError('Points cannot be negative');\n  }\n\n  if (!pointsUpdate.reason) {\n    throw new PointsUpdateError('Points update must have a reason');\n  }\n\n  return true;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Indexing"}),": Ensure blockId and userId fields are indexed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Date Indexing"}),": Index createdAt field for date range queries"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Batch Operations"}),": Use ",(0,o.jsx)(n.code,{children:"getAllPointsUpdates()"})," for bulk operations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Caching"}),": Consider caching aggregated points data"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pagination"}),": For large points lists, implement pagination"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"./block",children:"Block Management"})})," - Associate points with content blocks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"./user",children:"User Management"})})," - Track user points and progress"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"./quiz",children:"Quiz System"})})," - Award points for quiz completion"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"./fill-in-the-blank",children:"Fill-in-the-Blank"})})," - Award points for correct answers"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"This completes the comprehensive documentation for all Prisma abstraction modules. Each module provides type-safe, efficient, and well-documented functions for managing your Nuclear application's data layer."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);